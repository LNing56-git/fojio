# 标记

# 计网

### token

- 最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库
- 当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个 token 值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端
- 客户端拿到 token 值之后,进行本地保存；当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带到参数中发送给服务器

### TCP接收队列

操作系统收到的TCP数据包经过检查和处理后，就会保存到这个队列中

### TCP首部

- 固定部分：20字节
  - 源端口、目的端口
  - 序号、确认号
  - 数据偏移：即首部长度
  - 控制位：6个保留，剩下6个是
    - URG：告诉系统此报文段中有紧急数据，应尽快发送
    - ACK：仅当ACK = 1时确认号字段才有效；TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1
    - PSH：在一端的应用进程希望在键入一个命令后立即就能收到对方的响应；接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付
    - RST：当RST=1时，表明TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接
    - SYN：SYN置为1就表示这是一个连接请求或连接接受报文
    - FIN：当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接
  - 窗口：接收窗口的大小
  - 校验和：伪首部、首部和数据的校验和
  - 紧急指针：仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）；当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作；即使窗口为0时也可以发送紧急数据
- 长度可变部分
  - 选项（长度可变）
  - 填充部分

### UDP首部

- 固定为8字节
  - 源端口、目的端口
  - UDP长度：伪首部、首部和数据的总长
  - 校验和：伪首部、首部和数据的校验和

### TCP/UDP伪首部

- 在首部前面，不属于首部
- 长度为12字节
- 作用：这样的校验和，既校验了TCP&UDP用户数据的源端口号和目的端口号以及TCP&UDP用户数据报的数据部分，又检验了IP数据报的源IP地址和目的地址。伪报头保证TCP&UDP数据单元到达正确的目的地址
- 内容：
  - 源IP、目的IP
  - 8位填充0
  - 协议
  - TCP/UDP长度

### 若浏览器缓存和OS缓存中没有**HTTP服务器**的域名和IP的映射：DNS

- A通过交换机发送DNS报文给网关路由器
- 网关路由器把报文转发给DNS服务器
- DNS服务器在 DNS 数据库中查找待解析的域名
  - A到本地域名服务器进行递归查询：即本地域名服务器代替它进行查询
  - 本地域名服务器进行迭代查询：先通过根域名服务器知道.com这个顶级域名服务器的IP；再通过.com顶级服务器知道.baidu这个二级域名服务器的IP
- 原路返回
- A根据IP生成TCP套接字

### GET vs POST

- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

### http状态码

- 600 源站没有返回响应头部，只返回实体内容

### 各版本区别

- 1.0 vs 1.1
  - 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）

### http如何转为https

- 302 跳转
  - 服务端把所有的 HTTP 流量跳转到 HTTPS 上
  - 有安全漏洞：第一次访问站点的时候如果是 HTTP 就有可能被中间人劫持，很可能都没到 302 跳转的时候就被劫持了
- HSTS机制
  - 支持 HSTS 的服务端，可以强制访问它的浏览器使用 HTTPS 协议
  - 用户的浏览器一旦得到了 HSTS 的信息，下次再访问站点的时候客户端浏览器就会强制使用 HTTPS
  - 这样就解释了为什么我们使用主流浏览器输入网站域名的时候，都会自动跳转到 HTTPS 了：因为我们访问的大多是主流的大网站
  - 缺点
    - 假如用户的浏览器从未访问过这个站点，这个时候依然会有被劫持风险
    - 如果你的站点的 HTTPS 服务没有完全准备好，不要轻易的开启 HSTS 响应头。因为一旦浏览器得到这个响应头，就会在规定的 max-age 的时间段内强制使用 HTTPS 访问，如果你的服务没准备好，用户就会一直访问失败，并且不能降级

### 网络攻击

dns劫持 http劫持 ssl劫持 ssl剥离 syn洪泛 arp欺骗

### MSS

TCP可从缓存中取出并放入报文段中的最大数据数量

# c++&go

### 链接阶段（静态链接）

将多个目标文件及所需要的库连接成最终的可执行目标文件（即把每个符号的定义与一个内存位置关联起来）

### c++ 11新特性

- auto关键字：编译器可以进行自动类型推断，但不能用于函数传参及数组类型的推断
- nullptr关键字
- 智能指针
- 可以使用初始化列表来对类进行初始化
- 右值引用：实现移动语义和完美转发
- atomic原子操作用于多线程资源互斥操作
- 新增了一些STL容器：unordered_map unordered_set array等
- lambda表达式：定义一个匿名函数，可以捕获上下文中的变量
- 可变参数模板

### 为什么栈效率高

栈是OS提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行

# 框架

### thrift的优点

- thrift通过一个中间语言IDL(接口定义语言)来定义RPC的数据类型和接口,这些内容写在以.thrift结尾的文件中,然后通过特殊的编译器来生成不同语言的代码,以满足不同需要的开发者
- 已经支持很多协议，很多传输通道，不需要自己再封装协议并搭建、配置服务器,可以大大减少开发时间
- 数据结构与传输表现的分离，支持多种消息格式

### zookeeper与kafka

- 发布者将数据发布到ZooKeeper的一个或一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中管理和数据的动态更新
- 每个Broker在启动时都会到/brokers/ids下创建属于自己的节点（IP地址+端口）；Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除
- 生产者负载均衡：让生产者将消息合理地发送到这些分布式的Broker上
- 消费者负载均衡：每个partition 只能被同组的一个消费者（一个消费者组消费一个topic）进行消费，所以需要实现消息合理分配到同组的多个消费者上

### kafka

- partition：若一个partition有多个复制品，它们中会有一个是leader，其他是follower；leader处理该Partition分区的所有读和写请求；follower被动地复制leader做出的改变；如果该Partition分片的领导者发生了故障等，follower中会有一个成为leader
- broker：负责把数据存储到内存并持久化到磁盘
- request.required.acks 有三个值 0 1 -1
   - 0：生产者不等broker的ack
  - 1：生产者会等待leader 确认接收到消息后发送的 ack
  - -1：生产者会等所有的 follower 的副本收到数据后leader 发出的 ack

### merge vs rebase

- merge

  自动根据两个分支的共同祖先和两个分支的最新提交进行三方合并，然后将合并中修改的内容生成一个新commit，原来分支的commit记录仍然会保存

- rebase

  从两个分支的共同祖先提取当前分支上的修改，将当前分支上所有修改合并到目标分支的最新提交后面，所以rebase后只剩下一个分支的commit记录

### restful api

“无状态(Stateless)”思想：服务端不应该保存客户端状态，只需要处理当前的请求，不需了解请求的历史，客户端每一次请求中包含处理该请求所需的一切信息

# OS

### 进程 vs 线程

- 进程切换时，涉及虚拟空间的切换，而线程切换时只需CPU上下文，开销很小（为什么虚拟空间切换慢？把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用TLB作为缓存，加速页表查找。当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢）

### 进程的资源

- PCB（在内核空间中，内含pid、CPU现场<寄存器、指令计数器等的值>、页表起始地址、内存描述符、文件描述符表、进程状态、进程优先级等）

- 每个进程都有自己的“进程页表”，“进程页表”中映射的线性地址包括两部分：用户态、内核态；每个进程的“进程页表”中内核态地址相关的页表项都是“内核页表”的一个拷贝

### 进程切换步骤

模式切换（用户态到内核态）；<br />保存处理机现场到进程的PCB，包括程序计数器和其他寄存器；<br />更新PCB状态信息；<br />把进程的PCB移入相应的队列；<br />选择另一个进程执行，并更新其PCB状态信息；<br />更新页表（把即将运行进程的页表起始地址和页表长度存放在寄存器）（每个进程有自己的页表，相当于载入了新进程的虚拟空间）；<br />恢复处理机现场

### 线程的资源

- 共享的：文件描述符表、进程地址空间、信号处理函数、当前工作目录、 进程ID与进程组ID
- TCB（错误码、tid、线程状态、CPU现场<寄存器、指令计数器等的值>、线程优先级、线程专有存储区、堆栈指针等）

### 线程切换步骤

模式切换（用户态到内核态）；<br />保存处理机现场到线程的TCB，包括程序计数器和其他寄存器；<br />更新TCB状态信息；
把TCB移入相应队列；
选择另一个线程执行，并更新其TCB状态信息；<br />恢复CPU现场

### 协程

- 协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销
- 由于在同一个线程上，因此可以避免竞争关系而使用锁
- 协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上
- 协程拥有自己的寄存器上下文和栈
- 切换开销：修改寄存器的值即可，不需要从用户态切到内核态

### 共享内存

当进程脱离共享存储区后，计数器减一，挂架成功时，计数器加一，只有当计数器变为零时，才能被删除。当进程终止时，它所附加的共享存储区都会自动脱离

### 为什么要分用户态和内核态

- 安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源
- 封装性：用户程序不需要实现更加底层的代码
- 利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便

### 文件描述符表

在系统的文件描述符表中，每一行是{文件位置，引用计数<即指向该表项的描述符表项数>，inode表的某一行}的形式

### I/O定义

在主存和外部设备（如磁盘、终端、网络）之间拷贝数据的过程

# 数据库

### 索引

- 平衡多路查找树（B树）：所有叶子节点都在同一层
- 哈希索引
  - 哈希索引中只保存哈希值和行指针，不存储字段值
  - 哈希索引数据并非按索引值顺序存储，所以无法用于排序、只支持等值查询

### 索引的好处

- 大大减少了服务器需要扫描的数据行数
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

### MVCC具体过程

- 插入操作时，记录创建版本号
- 删除操作时，记录删除版本号
- 更新操作时，先记录删除版本号，再新增一行记录创建版本号
- 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）

### innodb

- 支持外键
- 支持行锁（若不能确定要扫描的范围，还是需要锁全表）
- 不保存表的行数（所以 select count(*) from table需要扫描全表统计行数）
- 采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放
- 加锁
  - 意向锁是 InnoDB 自动加的， 不需用户干预
  - 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)； 对于普通 SELECT 语句，InnoDB 不会加任何锁
- mysql默认的引擎：myisam

### InnoDB vs MyISAM

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁；InnoDB支持MVCC版本控制
- 外键：InnoDB 支持外键
- 备份：InnoDB 支持在线热备份（备份时数据库仍可用）
- 并发：InnoDB 读写阻塞与事务隔离级别相关；MyISAM读写互相阻塞：不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读
- 索引
- 存储：

  - InnoDB【索引和数据在一块】：表空间数据文件（由数据段和索引段组成，数据段即为B+树上的叶子节点；索引段就是B+树上的非叶子节点）和它的日志文件
  - MyISAM【索引和数据分开】：表保存为文件的形式（所以在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦）： .frm文件存储表定义，数据文件的扩展名为.MYD，索引文件的扩展名是.MYI
  - MyISAM 支持压缩表和空间数据索引，InnoDB需要更多的内存和存储
- 适用场景

### COUNT(*)\COUNT(1)\COUNT(col)

- COUNT(*)、COUNT(1) 返回组中的项数，包括 NULL 值和重复项
- COUNT(col)为了去除col列中包含的NULL行，必须读取该col的每一行的值，然后确认下是否为NULL，然后再进行计数
- COUNT(1)跟COUNT(主键)一样，只扫描主键；COUNT(*)跟COUNT(非主键)一样，扫描整个表

### redis列表

- 存储多个字符串
- 拥有例如：lpush lpop rpush rpop等等操作命令
- 应用场景：消息队列
- 底层实现：双向链表，每个节点都是一个压缩列表（包含多个entry）

### redis vs memcached

- Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点；Redis Cluster 实现了分布式的支持（主从复制）
- Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型
- 对一致性的保证：redis单线程模型，保证数据按顺序提交，利用队列技术将并发访问变为串行访问；memcached使用cas保持一致性

### redis是单线程的，为何如此高效

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速
- 数据以kv对形式存放，查找效率高
- 虽然redis文件事件处理器以单线程方式运行，但使用了I/O多路复用程序来监听多个套接字，只要有一个socket就绪了，I/O多路复用程序就会把消息放入队列中，文件事件分派器把消息转发到不同的事件处理器（连接应答、命令请求、命令回复处理器等）中
- 数据结构简单，对数据操作也简单
- 采用单线程，避免了不必要的上下文切换和对锁的竞争

### 不符合范式会有什么问题

- 冗余数据：某些同样的数据多次出现（如学生姓名）
- 修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改
- 删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）
- 插入异常：无法插入（插入一个还没有课程信息的学生）

### 如何提高mysql的读写性能

- 读写分离：让主数据库处理写，而从数据库处理读
- 选择合适的存储引擎：主库配置innodb；从库可配置myisam引擎，提升查询性能以及节约系统开销
- 把数据存在内存中：设置足够大的 innodb_buffer_pool_size
- 数据预热：数据库刚刚启动，需要进行数据预热，将磁盘上的所有数据缓存到内存中
- 减少磁盘写入操作：使用足够大的写入缓存 innodb_log_file_size；innodb_flush_log_at_trx_commit设置为每秒写入磁盘而不是每次修改都写入磁盘
- 使用合适的索引
- 分析查询日志和慢查询日志

### 分布式事务

- 2PC 两阶段提交
- 本地消息表

### 分布式系统特性

CAP

### 分区容忍性 P

分布式系统在遇到任何网络分区（节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信）故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障

### 基本可用（BA）

分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性

### paxos

用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值

### raft

Leader 会周期性的发送心跳包给 Follower

- 数据同步过程
  - 来自客户端的修改都会被传入 Leader。注意leader的该修改还未被提交，只是写入日志中
  - Leader 会把修改复制到所有 Follower
  - Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交
  - Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致

### zab

zookeeper使用的策略；在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞

### zab消息广播过程

- leader接收到消息请求后，将消息赋予一个全局唯一的zxid
- leader将带有zxid的消息作为一个提案（proposal）分发给所有的 follower
- follower接收到proposal，先把proposal写到磁盘，写入成功以后再向leader回复一个ack
- leader接收到合法数量（超过半数节点）的ack后，leader就会向这些follower发送commit命令，同时会在本地commit
- 当follower收到消息的commit命令以后，会提交该消息

### zab崩溃恢复过程

- 新选举Leader：选举拥有集群中所有机器最高编号（ZXID 最大）的事务Proposal的机器为新leader，从而保证这个新选举出来的 Leader 一定具有所有已经提交的提案

### 缓存问题

缓存穿透 缓存雪崩 缓存一致性

### 缓存雪崩

- 由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库
- 解决方法
  - 通过观察用户行为，合理设置缓存过期时间
  - 使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用
  - 进行缓存预热（提前将热点数据加载到缓存中），避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩

### 缓存一致性

- 要求数据更新的同时缓存数据也能够实时更新
- 解决方法
  - 在数据更新的同时立即去更新缓存
  - 在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新

# bq

### 怎么学习技术

书

公开课

技术博客

自己做项目练手

最重要的是：自己总结并更新自己的技术博客

### 崇拜的人

大一程设老师

魄力：cs当时并不是热门行业

自学能力：零基础转码

真正的大佬人都特别好：很有耐心

### 遇到问题一般怎么解决

我会先自己想造成这个问题的原因有可能是什么，然后一个一个去排除、尝试解决

如果实在解决不了，我会先google或者到stackoverflow上面搜一下，一般都能找到解决方法

还是解决不了的话，也可以问问身边的人，比如mentor或者其他同学同事

### 后端开发技能树

基础知识：数据结构和算法、数据库、计网、操作系统、分布式系统

框架和工具：比如分布式计算平台、消息队列、负载均衡器、版本管理工具，这些很实用的轮子，不仅要学会怎么用，还要争取看一下源码理解设计的思想

业务相关的知识：比如如果做短视频推荐，就应该了解推荐系统的结构是什么样的，系统的瓶颈在哪里，还有对推荐算法最好也要了解一下

# 智力题

### 甲乙最后三次抛硬币，正反反甲赢，反反正乙赢，俩人胜出概率谁大

   - 假设游戏过程中出现了一个“正”，但还没有分出胜利，那么乙就一定不会胜了
- 因为这种情况下乙要胜利，必须先扔出两个“反”，但如果扔出了两个“反”，甲就先胜利了
- 也就是说，乙要胜利，只有这些情况：“反反正”，“反反反正”，“反反反反正”，...，“反\*n正”
- 乙胜的概率是1/4

### 扔鸡蛋

- 可以将楼层划分成多个区间，第一个鸡蛋 E1 用来确定 N 属于哪个区间，第二个鸡蛋 E2 按顺序遍历该区间找到 N。那么问题就转换为怎么划分区间满足最坏情况下扔鸡蛋次数最少。
- E1 需要从第一个区间开始遍历到最后一个区间。如果按等大小的方式划分区间，即 E2 的遍历次数固定。那么最坏的情况是 N 在最后一个区间，此时 E1 遍历的次数最多。为了使最坏情况下 E1 和 E2 总共遍历的次数比较少，那么后面的区间大小要比前面的区间更小。具体来说，E1 每多遍历一次，E2 要少遍历一次，才使得 N 无论在哪个区间，总共遍历的次数一样。设第一个区间大小为 X，那么第二个区间的大小为 X-1，以此类推。那么 X + (X-1) + (X-2) + … + 1 = 100，得到 X (X + 1) / 2 = 100 ，即 X = 14

# 系统设计题

### 弱网

直接用ip，跳过dns解析
长连接
多路复用
压缩数据
加快对超时的判断，减少等待时间，尽早重试
允许服务器在客户端未请求时推送数据给客户端；这样客户端可以直接从本地加载这些资源，不用再通过网络

### 加载慢的原因

- 网络环境：弱网

- 服务器

  服务器性能有限，可以优化服务器配置：内存、CPU、带宽
  服务器遭到恶意攻击，有人大量发请求，可以禁止一些访问
  数据库瓶颈：慢查询多（可以优化sql）、db响应慢（可以存入redis）

- 请求的数据本身

  网页体积过大：通过外部文件的方式引用css和js文件
  有的静态资源特别大，拖累了整个网页的加载：可以使用CDN，如果它缓存了这部分的资源，就可以直接返回，如果没有缓存，也可以把对用户响应最快的节点返回给用户，然后用户向该节点发出请求

- 本地机器内存不够

### 秒杀系统

(1)秒杀开始前

将参加秒杀的商品信息事先缓存到redis中，将产品的业务唯一字段作为key，库存作为value
一个后台线程，阻塞等待商品库存售完的通知
(2)秒杀时

- 用户点击后响应前按钮置灰，禁止重复提交
- 用户是否超过访问频率限制【可以通过redis实现：以某个接口+用户唯一性标准为key，以访问次数为value，设置过期时间为1min】，是则返回访问频繁信息或要求输入验证码

   - 根据商品的key查询当前库存，如果==0，返回已售空信息，唤醒一开始启动的后台进程，它获取set集合中的用户信息，异步处理需要操作的购买等后续操作
   - 判断当前的set集合中是否有该用户ID，如果没有，减库存（通过redis的事务和watch命令，事务保证这些操作都执行或都不执行；watch是CAS乐观锁，保证库存的一致性，重试n次，n次返回均未成功，则接口返回失败）并且将用户的ID放入集合中；如果集合中已经存在该用户id，则不做任何处理，直接处理下一个请求

### 大文件，时间戳+日志内容，如何搜寻某段时间的日志内容

- 模拟B+树或OS中的多级页表，或者模拟redis中的跳跃表

### 如果有人恶意攻击网站，发送大量请求怎么办

(1)ddos攻击

- 对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务

(2)应对方法

- 添加服务器黑名单，禁止攻击者访问
- 对用户请求数据进行实时监控，及时发现DOS攻击等异常流量（比如空请求？），在不影响正常业务开展的情况下清洗掉这些异常流量
- CDN加速：CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃

# 面经

### 原子数量

```cpp
class Solution {
public:
    string countOfAtoms(string formula) {
        string res = "";
        int pos = 0;
        map<string, int> m = parse(formula, pos);
        for (auto a : m) {
            res += a.first + (a.second == 1 ? "" : to_string(a.second));
        }
        return res;
    }
    map<string, int> parse(string& str, int& pos) {
        map<string, int> res;
        while (pos < str.size()) {
            if (str[pos] == '(') {
                ++pos;
                for (auto a : parse(str, pos)) res[a.first] += a.second;
            } else if (str[pos] == ')') {
                int i = ++pos;
                while (pos < str.size() && isdigit(str[pos])) ++pos;
                int multiple = stoi(str.substr(i, pos - i));
                for (auto a : res) res[a.first] *= multiple;
                return res;
            } else {
                int i = pos++;
                while (pos < str.size() && islower(str[pos])) ++pos;
                string elem = str.substr(i, pos - i);
                i = pos;
                while (pos < str.size() && isdigit(str[pos])) ++pos;
                string cnt = str.substr(i, pos - i);
                res[elem] += cnt.empty() ? 1 : stoi(cnt);
            }
        }
        return res;
    }
};
```

### 平时关心什么新技术



### 最小元素与最大元素的和<=target 的非空子序列的数目

https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/solution/python-pai-xu-shuang-zhi-zhen-by-irruma/

### http幂等性

一次和多次请求某一个资源应该具有同样的副作用

幂等操作关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果

GET方法用于获取资源，不应有副作用，所以是幂等的

POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST  http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性

PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性

防止重复扣款的方法：用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id?amount=xxx来实现幂等的扣款操作

# 刷题

### 分数排名

```sql
select a.Score as Score,
(select count(distinct b.Score) from Scores b where b.Score >= a.Score) as Rank
from Scores a
order by a.Score DESC
```

### h2o生成

h：wait(h_count < 2); print('h'); ++h_count; if (h_count + o_count == 3) h_count = o_count = 0; notify();

o：wait(o_count < 1); print('o'); ++o_count; if (h_count + o_count == 3) h_count = o_count = 0; notify();

### 二分查找

有 right = mid; 一定要用 while (left < right) 而不是 <=

### 课程表（lc207）

从有向图中选择一个没有前驱（入度为0）的顶点输出。

删除该顶点顶点，并且删除从该顶点出发的全部边。

重复上述两步，直到剩余的网中不存在没有前驱的顶点为止

```cpp
vector<vector<int>> graph(numCourses, vector<int>()); // (A, 以A为先修课的课程)
vector<int> visited(numCourses, 0); // 记录课程是否被删除
vector<int> enter(numCourses, 0); // 记录课程的入度
queue<int> q; // 存放所有入度为0的课程
```

### 后序遍历

```cpp
void traverse(TreeNode* root) {
    stack<TreeNode*> myStack;
    TreeNode* lastvisit = root;
    while (!myStack.empty || root != nullptr) {
        if (root != nullptr) {
            myStack.push(root);
            root = root->left;
        } else {
            root = myStack.top();
            if (root->right == nullptr || root->right == lastvisit) {
                visit(root);
                myStack.pop();
                lastvisit = root;
                root = nullptr;
            } else {
                root = root->right;
            }
        }
    }
}
```

### 二叉树最大路径和

```cpp
int left = max(helper(node->left, res), 0);
```

### 中序遍历的下一个元素

```cpp
return pNode->next;
```

### 组合总和Ⅱ（元素只能取1次）（lc40）

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& num, int target) {
        vector<vector<int>> res;
        vector<int> cur;
        sort(num.begin(), num.end()); // 避免重复
        helper(num, target, 0, cur, res);
        return res;
    }
    void helper(vector<int>& num, int target, int pos, vector<int>& cur, vector<vector<int>>& res) {
        if (target < 0) return;
        if (target == 0) { res.push_back(cur); return; }
        for (int i = pos; i < num.size(); ++i) {
            if (i > pos && num[i] == num[i - 1]) continue; // 避免重复
            cur.push_back(num[i]);
            helper(num, target - num[i], i + 1, cur, res); // 传i + 1
            cur.pop_back();
        }
    }
};
```

### 最大交换（lc670）

从右到左找到每个数字右边的最大数字(包括其自身)；再从左到右遍历，如果某一位上的数字小于其右边的最大数字，说明需要调换；由于最大数字可能不止出现一次，这里希望能跟较低位的数字置换，这样置换后的数字最大，所以就从低位向高位遍历来找那个最大的数字，找到后进行调换即可

### 字典序排数

```cpp
 
bool cmp(pair<string, int> a, pair<string, int> b) {
	return a.first < b.first;
}
 
class Solution {
public:
    vector<int> lexicalOrder(int n) 
    {
        vector<int> ret;
        vector<pair<string, int>> mypair;
        for(int i = 1; i <= n;  i++)
        {
            mypair.push_back(pair<string, int>(std::to_string(i), i));
        }
        sort(mypair.begin(), mypair.end(), cmp);
        for(auto it = mypair.begin(); it != mypair.end(); it++)
        {
            ret.push_back(it->second);
        }
        return ret;
    }
};
```

### 重复的元素不保留（lc82）

```cpp
// 递归
ListNode* deleteDuplicates(ListNode* head) {
    if (!head) return head;
    if (head->next && head->val == head->next->val) {
        while (head->next && head->val == head->next->val) {
            head = head->next;
        }
        return deleteDuplicates(head->next);
    }
    head->next = deleteDuplicates(head->next);
    return head;
}
```

### 从中间拆分链表

```cpp
slow = head;
fast = head->next->next;
while (fast && fast->next)
```

### 环形链表求入口

```cpp
slow = head->next;
fast = head->next->next;
```

### 把int当作字符串反转（lc7）

```cpp
if (abs(y) > INT_MAX / 10) return 0;
```

### 小顶堆

```cpp
auto cmp = [](ListNode*& a, ListNode*& b) {
   return a->val > b->val;
};
priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)>  q(cmp);
```

### 顺时针旋转90°（lc48）

```cpp
void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            swap(matrix[i][j], matrix[j][i]);
        }
        reverse(matrix[i].begin(), matrix[i].end());
    }
}
```

### 和为target的子数组个数

```cpp
res += m[sum - k];
```

### 最长上升子序列（lc300）

dp[i]表示以nums[i]结尾的最大上升子序列长度

```cpp
vector<int> dp(n, 1);
res = max(res, dp[i]);
```

法二：先建立一个空的 dp 数组，然后开始遍历原数组，对于每一个遍历到的数字，用二分查找法在 dp  数组找第一个不小于它的数字，如果这个数字不存在，那么直接在 dp  数组后面加上遍历到的数字，如果存在，则将这个数字更新为当前遍历到的数字，最后返回 dp 数组的长度即可

### 最长连续序列（lc128）

```cpp
int longestConsecutive(vector<int>& nums) {
    int res = 0;
    unordered_set<int> s(nums.begin(), nums.end());
    for (int num : nums) {
        if (!s.count(num)) continue;
        s.erase(num);
        int pre = num - 1, post = num + 1;
        while (s.count(pre)) s.erase(pre--); // 记得要erase而不是只--！
        while (s.count(post)) s.erase(post++);
        res = max(res, post - pre - 1);
    }
    return res;
}
```

### 分发糖果（lc135）

```cpp
if (ratings[i] < ratings[i + 1]) candies[i + 1] = candies[i] + 1; // 从左往右扫时
if (ratings[i] < ratings[i - 1]) candies[i - 1] = max(candies[i - 1], candies[i] + 1); // 从右往左扫时
```

### 每日温度（lc739）

把在数组中的位置而不是元素的值放入栈中

从左向右遍历，当前温度比栈顶温度高，则更新栈顶的res，并且出栈

```cpp
vector<int> dailyTemperatures(vector<int>& temperatures) {
    int n = temperatures.size();
    vector<int> res(n, 0);
    stack<int> st;
    for (int i = 0; i < temperatures.size(); ++i) {
        while (!st.empty() && temperatures[i] > temperatures[st.top()]) { // 注意要判断!st.empty()
            auto t = st.top(); st.pop();
            res[t] = i - t;
        }
        st.push(i);
    }
    return res;
}
```

### 滑动窗口最大值（lc239）

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    if (k == 1) return nums;
    int n = nums.size();
    vector<int> res;
    map<int, int> m;
    for (int i = 0; i < k; ++i) {
        ++m[nums[i]];
    }
    res.push_back(m.rbegin()->first);
    for (int i = 1; i <= n - k; ++i) {
        --m[nums[i - 1]];
        if (!m[nums[i - 1]]) m.erase(nums[i - 1]);
        ++m[nums[i + k - 1]];
        res.push_back(m.rbegin()->first);
    }
    return res;
}
```

### 三角形路径和（lc120）

改进：不用额外的dp数组，直接把和累加到triangle中

### 俄罗斯套娃信封问题（lc354）

给所有的信封按从小到大排序：首先根据宽度从小到大排，如果宽度相同，那么高度小的再前面，这是STL里面sort的默认排法；对于每一个信封，遍历其前面所有的信封，如果当前信封的长和宽都比前面那个信封的大，那么dp[i] = max(dp[i], dp[j] + 1)；每遍历完一个信封，更新res

### 接雨水（lc42）

```cpp
int trap(vector<int>& height) { // 每个柱子上方能储存的水是由它左边的最大值和右边的最大值中的较小值决定的
    int n = height.size();
    if (!n) return 0;
    int res = 0;
    int left_max = 0, right_max = 0; // left_max：左边的最大值，它是从左往右遍历找到的
    int left = 0, right = n - 1; // left：从左往右处理的当前下标
    while (left <= right) {
        if (left_max <= right_max) {
            res += max(0, left_max - height[left]); // 从左往右处理时，left_max是可信的
            left_max = max(left_max, height[left]);
            ++left;
        } else {
            res += max(0, right_max - height[right]);
            right_max = max(right_max, height[right]);
            --right;
        }
    }
    return res;
}
```

### 柱状图中的最大矩形（lc84）

遍历数组，每找到一个局部峰值（只要当前的数字大于后面的一个数字，那么当前数字就看作一个局部峰值，跟前面的数字大小无关），然后向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值

### 排序算法总结

不稳定的：选择、快排、堆排序、希尔排序

空间复杂度：归并n、快排logn

### 归并排序

```cpp
void sort(vector<int>& nums) {
    mergeSort(nums, 0, nums.size() - 1);
}

void mergeSort(vector<int>& nums, int l, int r) {
    if (l >= r) return;
    int mid = l + (r - l) / 2;
    mergeSort(nums, l, mid);
    mergeSort(nums, mid + 1, r);
    merge(nums, l, mid, r);
}

void merge(vector<int>& nums, int l, int mid, int r) {
    vector<int> tmp(l - r + 1);
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (nums[i] <= nums[j]) tmp[k++] = nums[i++];
        else tmp[k++] = nums[j++];
    }
    while (i <= mid) tmp[k++] = nums[i++];
    while (j <= r) tmp[k++] = nums[j++];
    for (k = 0, i = l; i <= r; ++i, ++k) {
        nums[i] = tmp[k];
    }
}
```

### 快排

```cpp
void sort(vector<int>& nums) {
    quickSort(nums, 0, nums.size() - 1);
}

void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    int pivot = partition(nums, left, right);
    quickSort(nums, left, pivot - 1);
    quickSort(nums, pivot + 1, right);
}

int partition(vector<int>& nums, int left, int right) {
    int pivot = nums[left], l = left + 1, r = right;
    while (l <= r) { // <=
        if (nums[l] > pivot && nums[r] < pivot) { // 是if不是while
            swap(nums[l++], nums[r--]);
        }
        if (nums[l] <= pivot) ++l; // 是if不是while
        if (nums[r] >= pivot) --r; // 是if不是while
    }
    swap(nums[left], nums[r]);
    return r;
}
```

### 堆排序

```cpp
void heapSort(vector<int> nums) {
    for (int i = (nums.size() - 1) / 2; i >= 1; --i) { // 从右往左处理非叶子节点
        sink(i);
    }
    for (int i = nums.size() - 1; i > 1; --i) {
        swap(nums[i], nums[1]);
        sink(1);
    }
}
```

### rand7实现rand10

先用rand7实现rand10*N（以rand40为例）：(rand7 - 1) * 7 + rand7，就转为了 rand49

用  rand49() 生成一个 [1, 49] 范围内的随机数，如果其在 [1, 40] 范围内，则进入下一步，否则重新rand49；这样就转为了rand40

rand40 % 10 + 1转为 rand10

### topk

```cpp
int findKthLargest(vector<int>& nums, int k) {
    int left = 0, right = nums.size() - 1;
    while (true) {
        int pos = partition(nums, left, right);
        if (pos == k - 1) return nums[pos];
        if (pos > k - 1) right = pos - 1;
        else left = pos + 1;
    }
}

int partition(vector<int>& nums, int left, int right) {
    int pivot = nums[left], l = left + 1, r = right;
    while (l <= r) {
        if (nums[l] < pivot && nums[r] > pivot) {
            swap(nums[l++], nums[r--]);
        }
        if (nums[l] >= pivot) ++l;
        if (nums[r] <= pivot) --r;
    }
    swap(nums[left], nums[r]);
    return r;
}
```

### 圆圈游戏（jz46）

当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有 f(n, m) = (m % n + x) % n = (m + x) % n

f[n] = (f[n-1] + m) % n

### 幂（lc50）

```cpp
double myPow(double x, int n) {
    if (n == 0) return 1;
    double half = myPow(x, n / 2);
    // n 为偶数
    if (n % 2 == 0) return half * half;
    // n 为奇数
    if (n > 0) return half * half * x;
    return half * half / x;
}
```

### LRU

```cpp
l.splice(l.begin(), l, l_iter);
l.push_front(make_pair(key, value));
l.pop_back();
```

### LFU（lc460）

```cpp
class LFUCache {
public:
    LFUCache(int capacity) {
        cap = capacity;
    }
    
    int get(int key) {
        if (m.count(key) == 0) return -1;
        freq[m[key].second].erase(iter[key]);
        ++m[key].second;
        freq[m[key].second].push_back(key);
        iter[key] = --freq[m[key].second].end();
        if (freq[minFreq].size() == 0) ++minFreq;
        return m[key].first;
    }
    
    void put(int key, int value) {
        if (cap <= 0) return;
        if (get(key) != -1) {
            m[key].first = value;
            return;
        }
        if (m.size() >= cap) {
            m.erase(freq[minFreq].front());
            iter.erase(freq[minFreq].front());
            freq[minFreq].pop_front();
        }
        m[key] = {value, 1};
        freq[1].push_back(key);
        iter[key] = --freq[1].end();
        minFreq = 1;
    }

private:
    int cap, minFreq;
    unordered_map<int, pair<int, int>> m; // {key，(value，key使用次数)}
    unordered_map<int, list<int>> freq; // {key使用次数，相同使用次数的key}
    unordered_map<int, list<int>::iterator> iter; // {m中的key，freq中list中的key}
};
```
