七 锁
1-1.syncronized 同步阻塞锁
(1)概述
悲观锁：其他线程会被阻塞
加了同步锁之后，自增的操作变成了原子性操作
会让没有得到锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高
(2)作用：当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码
(3)作用域：对于同步方法，锁是当前实例对象。对于静态同步方法，锁是当前对象的Class对象。对于同步方法块，锁是Synchonized括号里配置的对象。
①对方法使用synchronized关键字：public synchronized void func ()
a. 如果一个对象实例有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象实例中任何一个synchronized方法（不同的对象实例的synchronized方法不相干扰）
b. synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用
②对代码块使用synchronized关键字：synchronized(this){/区块/}
这时锁就是对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁
class Foo implements Runnable {
   private byte[] lock = new byte[0]; // 特殊的instance变量    
   Public void methodA() {      
     synchronized(lock) { //… }
   }
   //…..
}
③对类使用synchronized关键字：synchronized (SynchronizedExample.class) { ... }
作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步
(4)原理
所有类实例（即对象）都自动含有单一的监视器锁monitor（在对象头中）
通常使用CAS更新对象头
JVM负责跟踪对象被加锁的次数。如果一个对象被解锁，其计数变为0。在任务（线程）第一次给对象加锁的时候，计数变为1。每当这个相同的任务（线程）在此对象上获得锁时，计数会递增
只有首先获得锁的任务（线程）才能继续获取该对象上的多个锁
每当任务离开一个synchronized方法，计数递减，当计数为0的时候，锁被完全释放，此时别的任务就可以使用此资源
不光是类实例，每一个类也对应一把锁，用来处理静态成员
每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态

1-2.lock 同步阻塞锁 之ReentrantLock


2.CAS 比较并替换 同步非阻塞锁
是乐观锁：每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止
应用：一系列以 Atomic 开头的包装类，用CAS实现原子操作
用volatile保证获得的当前值是内存中的最新值
使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B
更新一个变量的时候，只有当变量的旧预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B；若不相同，则进行自旋：重新获取内存地址V的当前值作为A，并重新计算想要修改的新值B
是怎么保证原子性的：调用了unsafe的compareAndSwapInt方法，是硬件级别的原子操作（处理器执行CMPXCHG指令）
缺点：CPU开销较大（并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力）；CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性（比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了）；ABA问题
ABA问题：https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg
如何解决ABA问题：在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致

3.volatile
(1)作用：保证变量的可见性，即被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象；禁止进行指令重排序
(2)实现：当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存（但这个操作不是原子的：包括2个操作，修改线程工作内存中的值，然后将修改后的值写入主存），且其他线程的工作内存中该变量被标记为无效（因为在主存中存放的地址可能会变），当有其他线程需要读取时，它会去主存中读取新值（注意即使变量有效也是去主存读值的）
(3)为什么会出现脏读
Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。变量的值何时从线程的工作内存写回主存，无法确定。
(4)volatile不保证原子性
假如某个时刻变量inc的值为10，
线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；
然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。
然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。
那么两个线程分别进行了一次自增操作后，inc只增加了1
(5)volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性
在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行
(6)volatile的实现原理
加入volatile关键字时，汇编代码中会多出一个lock前缀指令
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
①确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
②强制将对缓存的修改操作立即写入主存
③如果是写操作，它会导致其他CPU中对应的缓存行无效（即变量失效）
(7)使用场景
需要保证对变量的操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行
没必要对常量和已在syncronized代码块中的变量用volatile
尽量少用volatile，因为它禁止了代码优化

4.物理机的内存：https://www.jianshu.com/p/15106e9c4bf3 图1
(1)概述
程序运行过程中的临时数据存放在主存中
每个cpu有自己的高速缓存
当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中
(2)栗子：线程执行i = i + 1;的过程
当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中
(3)解决缓存不一致的方法
①硬件层面的方法
在总线加LOCK#锁，阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存
缓存一致性协议（如MESI协议）：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取

5.java虚拟机的内存模型 JMM：https://www.jianshu.com/p/15106e9c4bf3 图2
(1)概述
Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果
Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。变量的值何时从线程的工作内存写回主存，无法确定。
(2)内存间交互的操作：原子操作
    read：把一个变量的值从主内存传输到工作内存中
    load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
    use：把工作内存中一个变量的值传递给执行引擎
    assign：把一个从执行引擎接收到的值赋给工作内存的变量
    store：把工作内存的一个变量的值传送到主内存中
    write：在 store 之后执行，把 store 得到的值放入主内存的变量中
    lock：作用于主内存的变量
    unlock
但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性


6.并发编程的三大问题及java提供的支持
(1)原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作
x = 10;         //原子：将数值10写入到工作内存
y = x;         //非原子：先要去读取x的值，再将x的值写入工作内存
x++;           //非原子：读取x的值，进行加1操作，写入新的值
x = x + 1;     //非原子：读取x的值，进行加1操作，写入新的值
【不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。】
【如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性】
【java对原子性的支持：Atomic、锁】
(2)可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
Java提供了volatile关键字来保证可见性（见上文）
通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性
【java对可见性的支持：volatile、锁】
(3)有序性：程序执行的顺序按照代码的先后顺序执行（JVM在真正执行代码时可能会做指令重排序来优化代码，处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行；指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性）
可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性
可以通过volatile关键字来保证一定的“有序性”（见上文）
Java内存模型具备一些先天的“有序性”：只有两个操作的执行次序无法从happens-before原则推导出来，那么虚拟机才可以随意地对它们进行重排序（happens-before原则们：①一段程序代码的执行在单个线程中看起来是有序的，即结果与按序执行相同；②无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作；③对一个变量的写操作先行发生于后面对这个变量的读操作；④如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；⑤Thread对象的start()方法先行发生于此线程的每个一个动作；⑥对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；⑦线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；⑧一个对象的初始化完成先行发生于他的finalize()方法的开始）
【java对有序性的支持：volatile、锁】

7.一些比较
(1)Volatile 与synchronized 区别
volatile不会加锁，也就不会使线程阻塞，所以volatile是比synchronized更轻量级的同步机制
volatile只保证可见性，synchronized保证可见性和原子性
(2)synchronizated 和 ReentrantLock 差别
synchronized是关键字，属于JVM层面；Lock是java.util.concurrent.locks包中的一个接口 是API层面的锁 是JDK实现的
synchronized不需要手动释放锁，当synchronized代码执行完后系统自动让线程释放对锁的占用；Lock则需要用户手动释放没有主动释放的锁，可能出现死锁现象。需要lock、unlock和try/catch一起使用
synchronizated不可中断，除非抛出异常或者正常运行完成，一个线程获取不到锁就一直等着；Lock可中断（设置超时方法tryLock 或 lockInterruptibly()放代码块中，调用interrupt()方法中断）
synchronizated是非公平锁；Lock源码：默认是非公平锁。也可以传参true为公平锁 false为非公平锁
synchronizated只能随机唤醒一个（notify()），或者唤醒全部唤醒（notifyAll()）；Lock用来实现分组唤醒需要唤醒的线程，可以精确唤醒某个线程
synchronizated不能判断锁的状态；Lock可以

8.锁的一些性质
(1)可重入锁（synchronized、ReentrantLock）
又名递归锁
当线程尝试获取锁时，可重入锁先尝试获取并更新父类AQS中的status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。
释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。
可重入锁的作用：可一定程度避免死锁，比如一个线程在外层方法获取锁的时候，再进入该线程的内层方法，status++即可
(2)响应中断（Lock）
响应中断就是一个线程获取不到锁，不会傻傻的一直等下去，会给予一个中断回应，然后去做其他事
(3)唤醒线程
(4)公平锁（Lock可实现）与非公平锁（Lock可实现、synchronized）
公平锁：在锁上等待时间最长的线程将获得锁的使用权
非公平锁：随机的获取，cpu时间片轮到哪个线程，哪个线程就能获取锁
公平锁实现机制：要求当一个线程竞争某个对象锁时，只要这个锁的等待队列非空，就必须把这个线程阻塞并塞入队尾
非公平锁实现机制：每个线程都先要竞争锁，在竞争失败或当前已被加锁的前提下才会被塞入等待队列，在这种实现下，后到的线程有可能无需进入等待队列直接竞争到锁
(5)乐观锁（Lock、CAS）和悲观锁（synchronized）
悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景
乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景
  - 实现方式：
    *加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段
    *先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新
(6)按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁
		加锁       					解锁							竞争锁失败		膨胀
偏向锁	偏向线程第一次进入同步块时		有另一个线程来竞争锁的时候		膨胀为轻量级锁	有另一个线程来竞争锁的时候
轻量级锁	进入同步块					退出同步块					自旋尝试抢占锁	竞争线程尝试占用轻量级锁失败多次之后
重量级锁	进入同步块 					退出同步块 					线程阻塞（释放锁后，唤醒阻塞的线程）
(7)自旋锁
当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环
缺点：消耗CPU；不公平
优点：自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的（线程进入阻塞状态会造成用户态和内核态的转换，代价高）

9.选择synchronized还是ReentrantLock
除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

10.java内存分区
