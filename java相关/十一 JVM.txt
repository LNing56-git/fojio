十一 JVM
1.内存分区（总图：见PDF P113）
(1)运行时数据区域（图：见cyc java虚拟机 图1 https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67）
①概述
每个线程有自己的程序计数器、虚拟机栈和本地方法栈
线程们共享：方法区（含运行时常量池）、堆区
运行时数据区域外有：直接内存
②程序计数器
记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）
是唯一一个没有OOM异常的区域
③java虚拟机栈
每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息
从方法调用直至执行完成的过程，对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程
可以通过 -Xss 这个虚拟机参数来指定每个线程的Java虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M
当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常
栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常
④本地方法栈
本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理
本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务
⑤堆区
所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）
可以将堆分为新生代和老生代，垃圾收集器对它们的收集算法不同
堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常
可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值
⑥方法区（永久代）
在HotSpot中，方法区仅仅只是逻辑上的独立，实际上还是包含在Java堆中，也是就说，方式区在物理上属于Java堆区中的一部分
用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
不需要连续的内存，并且可以动态扩展，动态扩展失败会抛出 OutOfMemoryError 异常
对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现
在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中
关于常量池：Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域；除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()；常量池无法申请内存时抛出OOM异常
⑦直接内存
NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作

(2)垃圾收集（GC）
①垃圾回收的对象
主要是针对堆和方法区进行
程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失
②判断一个对象是否可以被回收
a. 引用计数算法
为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减 1。引用计数为 0 的对象可被回收
因为循环引用的存在，Java 虚拟机不使用引用计数算法
b. 可达性分析算法
以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收
GC Roots包括：虚拟机栈中局部变量表中引用的对象；本地方法栈中 JNI 中引用的对象；方法区中类静态属性引用的对象；方法区中的常量引用的对象
③方法区的回收：对常量池的回收和对类的卸载
类的卸载必须满足的条件（必要不充分）：该类的所有实例都已经被回收；加载该类的ClassLoader已经被回收；该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法
④垃圾收集算法
a. 标记-清除
标记阶段：程序检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记
清除阶段：进行对象回收（即把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块）并取消标志位；判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块
缺点：会产生大量不连续的内存碎片，导致无法给大对象分配内存；标记和清除过程效率都不高
b. 标记-整理
算法：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
优点：不会产生内存碎片
缺点：需要移动大量对象
c. 复制
算法：将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理
缺点：只使用了内存的一半
现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor
HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%
如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象
d. 分代收集
算法：现在的商业虚拟机采用分代收集算法
    新生代使用：复制算法
    老年代使用：标记 - 清除 或者 标记 - 整理 算法
⑤垃圾收集器
HotSpot 虚拟机中有7个垃圾收集器，可配合使用
串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行
除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行
a. Serial 收集器：单线程、串行
它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率
Client 场景下的默认新生代收集器
b. ParNew 收集器：Serial 收集器的多线程版本
Server 场景下默认的新生代收集器
c. Parallel Scavenge 收集器：多线程、串行
“吞吐量优先”收集器：这里的吞吐量指CPU用于运行用户程序的时间占总时间的比值
高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务（因为停顿时间长，用户交互体验差）
d. Serial Old 收集器：Serial 收集器的老年代版本
e. Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本
f. CMS 收集器
分为以下四个流程：
    初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
    并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
    重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
    并发清除：不需要停顿。
缺点：
    吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
    无法处理浮动垃圾（并发清除阶段由于用户线程继续运行而产生的垃圾），这部分垃圾只能到下一次 GC 时才能进行回收
    标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC
g. G1 收集器
面向服务端应用的垃圾收集器
其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收
G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离，每个小空间可以单独进行垃圾回收
通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region

2.内存分配策略
(1)对象优先在新生代 Eden 分配，当 Eden 空间不够时，发起 Minor GC
(2)大对象直接进入老年代
(3)长期存活的对象进入老年代：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中
(4)动态对象年龄判定：如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代
(5)空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的

3.Minor GC 和 Full GC
(1)定义
Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快
Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多

(2)触发条件
Minor GC：Eden 空间满时
Full GC：调用 System.gc()时（只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行）；老年代空间不足；空间分配担保失败（使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC）

4.类加载机制
(1)概述
类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类
如果一次性加载，那么会占用很多的内存
类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次
(2)类的生命周期
包括以下 7 个阶段：
    加载（Loading）：通过类的完全限定名称获取定义该类的二进制字节流；把类的静态存储结构转换为方法区的运行时存储结构；在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口
    验证（Verification）：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
    准备（Preparation）：为static变量分配方法区的内存并设置初始值；初始值一般为 0 值；如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0
    public static int value = 123; // 初始化为0
    public static final int value = 123; // 初始化为123
    解析（Resolution）：将常量池的符号引用替换为直接引用
    初始化（Initialization）：执行类构造器 <clinit>() 方法（用程序里写的值初始化static变量和其它资源、执行静态代码块）
    使用（Using）
    卸载（Unloading）
动态绑定：交换解析和初始化的顺序（即先初始化再解析）
(3)类初始化的时机
①遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化
②使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化
③当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
④当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类
*注意：通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化
(4)双亲委派模型
启动类加载器-扩展类加载器-应用程序类加载器-自定义类加载器（前面的是父类加载器，后面的是子类加载器）
一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载

5.内存泄露
(1)内存溢出 OOM
堆上无内存可完成实例分配且堆无法扩展时
方法区无法满足内存分配需求时
虚拟机栈和本地方法栈扩展时无法申请到足够内存
(2)内存泄漏
程序动态分配了内存，但程序结束时未释放这部分内存，导致那部分内存不可用
java也会有内存泄漏：当被分配的对象可达但是已没有作用时，比如 S s = new S(); 然后往ArrayList里放s，再把s设置为null，但这个对象所占内存并未释放，因为ArrayList里还存着对象的引用
【arraylist中存入的是对象的引用而不是对象本身！！！】
(3)内存溢出与内存泄漏的区别
内存泄漏积累起来将导致内存溢出
内存泄漏可以通过完善代码来避免；内存溢出可以通过调整配置来减少发生频率，但无法彻底彼岸

6.堆和栈的区别
栈：
1）栈的存取速度比堆快，仅次于直接位于CPU的寄存器。
2）栈中的数据的大小和生存周期是确定的。
3）栈存储的是局部变量，不需要垃圾回收
堆：
1）堆可以动态的分配内存大小，生存期也不必告诉编译器。
2）堆在运行时动态分配内存，存取速度慢。
3）存储的是对象，需要垃圾回收